# [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

## 题目

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

- '.' 匹配任意单个字符

- '*' 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

示例 1：

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

示例 3：

```
输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

`注意：这里的*一定有字符，p不会是单个*输入，而且*和它前面的那个字符在s中可能出现，也可能没有`

## 题解

一种递归加动态规划的思想：超赞！！！大佬真牛

一般情况正常一样的字符或者`.`匹配是很简单的，确保两个字符串都有值，且相等或p为`.`，然后递归s和p同时++。

如果遇到\`*`那么就需要分两种情况

- 匹配0个，这个时候first_match就没用了，不管它是不是true，匹配0个的时候，\*和它前面那个字符无效，使用p+2跳过
- 匹配1个到多个，这个可以递归去做，然后确保每一步都是true

```c
bool isMatch(char * s, char * p){
    if (!*p) return !*s;
    bool first_match = *s && (*s == *p || *p == '.');
    if (*(p+1) == '*') {
        return isMatch(s, p+2) || (first_match && isMatch(++s, p));
        // 匹配0个（这个时候前面的first_match就没用了）  || 递归
    }
    else {
        return first_match && isMatch(++s, ++p);
    }
}
```

