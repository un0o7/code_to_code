# 3.[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

**Tags**

[`hash-table`](https://leetcode.com/tag/hash-table) | [`two-pointers`](https://leetcode.com/tag/two-pointers) | [`string`](https://leetcode.com/tag/string) | [`sliding-window`](https://leetcode.com/tag/sliding-window)

**Companies**

`adobe`` | ``amazon`` | ``bloomberg`` | ``yelp`

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

## 解题

这题实际上要用哈希表的方法来做，加上滑动窗口的方法。

[【Leetcode】无重复字符的最长子串 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/136063090)

### 滑动窗口解法

```c
 #include <string.h>
int isin(char c, char *s, int len)
{
    int i;

    for (i = 0; i < len; i++)
    {
        if (s[i] == c)
            return 1;
    }
    return 0;
}
int lengthOfLongestSubstring(char *s)
{
    if (!s)
        return 0;
    long int len = strlen(s);
    if (len == 0)
        return 0;

    int max = 1;
    int i = 0, j = 0;
    while (i < len && (j + 1) < len)
    {
        if (isin(s[j + 1], &s[i], j - i + 1))
        {
            i++;
            //这里是可以优化的，
            // 可以直接跳到两个重复字符前者的后一个位置，然后j后移1
        }
        else
        {
            j++;
            max = max > j - i + 1 ? max : j - i + 1;
        }
    }
    return max;
}
```

### 滑动窗口的改进方法

改进了，但是题目的输出反而没有上面那个效果好。

和KMP算法改进BP类似，每次匹配到相同不同让`i`只加1，而是跳到前一个重复字符的后一个位置上。

```c
int lengthOfLongestSubstring(char *s)
{
    if (!s)
        return 0;
    long int len = strlen(s);
    if (len == 0)
        return 0;

    int max = 1;
    int i = 0, j = 0;
    int tmp = 0;
    int flag = 0;
    while (i < len && (j + 1) < len)
    {
        printf("i=%d,j=%d\n", i, j);
        tmp = i;
        flag = 0;
        while (tmp < j + 1)
        {
            if (s[tmp] == s[j + 1])
            {
                i = tmp + 1;
                j++;
                flag = 1;
                break;
            }
            tmp++;
        }
        if (flag == 0)
        {
            j++;
            max = max > j - i + 1 ? max : j - i + 1;
        }
    }
    return max;
}
```

### 至强法（copilot生成）

哈希表本身的碰撞检测不就是跟这里的重复字符一致麻。

![image-20220726185714762](images/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/image-20220726185714762.png)

```c
int lengthOfLongestSubstring(char *s)
{
    int len = strlen(s);
    int i = 0, j = 0, max = 0;
    int hash[256] = {0}; //其实就是正在滑动窗口里面的字符对应位置置为1
    // 没有遍历到的和已经遍历但是因为重复过去的，置为0
    while (i < len && j < len)
    {
        if (hash[s[j]] == 0)
        {
            hash[s[j]] = 1;
            j++;
            max = max > j - i ? max : j - i;
        }
        else
        {
            hash[s[i]] = 0;
            i++;
        }
    }
    return max;
}
```

