# **BM64** **最小花费爬楼梯**

## 题目

![image-20220709202851789](https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220709202852261-461657430.png)

```
输入：[1,100,1,1,1,90,1,1,80,1]
返回值：6
说明：
你将从下标为 0 的台阶开始。
1.支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
2.支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
3.支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
4.支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
5.支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
6.支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。    
```

## 解题

递归实际上可以解决该问题，但是会超时。使用动态规划的方法，但是我始终不知道动态规划究竟是啥，这题的思路是一种状态转移，收缩前面序列。

动态规划最核心的思想，就在于**拆分子问题，记住过往，减少重复计算**。

参考：[(7条未读通知) BM64. [最小花费爬楼梯\]_资源分享_牛客网 (nowcoder.com)](https://ac.nowcoder.com/discuss/843492?type=5&order=0&pos=21&page=0&channel=-1&source_id=discuss_tag_nctrack)

下面构建的一个数组指的是**到达该位置的最小花费**。到达一个位置的最小花费存在两种计算方式：

- 经过两跳到达的：即到达前两个位置的最小花费加上前两个位置的花费。
- 经过一跳到达的：同理。

第一个位置和第二个位置因为可以跳过第一个所以最小花费均为0.

- 

![alt](https://img2022.cnblogs.com/blog/2348945/202207/2348945-20220709202948890-2124283909.gif)

```c
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param cost int整型一维数组 
 * @param costLen int cost数组长度
 * @return int整型
 *
 * C语言声明定义全局变量请加上static，防止重复定义
 */
int min(int a,int b){
    return a<b?a:b;
}

int minCostClimbingStairs(int* cost, int costLen ) {
    if(costLen==1) return cost[0];
    int dp[costLen+1];
    dp[0] = 0;
    dp[1] = 0;
    for(int i = 2; i < costLen+1; i++){
        dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
    }
    return dp[costLen];
        
}
```

